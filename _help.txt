Mostly everything in Dart is a class, and objects are instances of these classes (numbers, functions and even null are objects).
Collection-if/for/spread(...list, ...map): if (addblue) 'blue',
158. video: Dartx
//TODO
/// documentation

dart create
code .
flutter pub get
dart main.dart

dart pub outdated --mode=null-safety
dart pub upgrade --null-safety
dart pub get
dart migrate
dart analyze     # or `flutter analyze`
dart test     # or `flutter analyze`

TYPE CONVERSION:
double.parse()
int.tryparse()
.toInt() .toDouble()
.round()
.toString()
.toStringAsFixed(1)
as String

INPUT:
import 'dart:io';
stdout.write('');
final input = stdin.readLineSync();

RANDOM:
import 'dart:math';
final rng = Random();
rng.nextInt(3)

STRING:
.toUpper()
.contains()
.split(',');
.replaceAll(,);

LIST (COLLECTIONS):
.length
.isEmpty
.isNotEmpty
.first
.last
.add('new item');
.addAll(otherList);
.insert(1, 'new item');
.remove('item');
.removeAt(0);
.clear();
.contains('item');
.indexOf('item');
list2 = [...list1];

.forEach(print);
.map((value) => value * 2); (map creates a lazy iterable, so toList() can help) Iterable<T> map<T>(T Function(int) f)
.where((value) => value % 2 ==0);
.firstWhere((x) => x == 5, orElse: () => -1);

final sum = list.reduce((value, element) => value + element);

collection-if: if (addBlue) 'blue'
			   if (addAll) ...['yellow','brown'],


SET:
.add('new item');
.elementAt(0);
.union(anotherSet)
.intersection(anotherSet)
.difference(anotherSet)

MAPS:
if (mymap['something']) == null)
mymap.keys/values/entries -> entry.key, entry.value
mymap.containsKey(mykey)
mymap.isEmpty

FILE:
File(inputFile).readAsLinesSync();

NULL SAFETY (everything non-nullable must be initialized right away (classes), or through flow analysis (functions), or late)
int? value;
int sign = x >= 0 ? 1 : -1;
int newValue = myValue! (assertion)
int newValue = myValue ?? 0; (if null)  //? if not null
newValue ??= 0; (augmented assignment if-null operator: assign 0 only if it is currently null)

for(var city in cities) {
	print(city?.toUpperCase());
} // if not null execute toUpperCase(), otherwise print null)

EQUATABLE (only use with immutable classes => properties must be final)
dependencies:
  equatable: ^2.0.3
  
class Point extends Equatable {
  const Point(this.x, this.y);
  final int x;
  final int y;

  @override
  List<Object?> get props => [x,y];
  
CASCADE(Path? path;)
?..
(not needed for non-nullable: Path path = Path();)
..

----
void main() {
  final list2 = (([1, 0, 2]..sort()).reversed.toList()
    ..addAll([5, 3, 4])
    ..sort())
    .map((e) => e + 1).toList();
  print(list2);
}
----